#include<stdio.h>
#pragma warning(disable:4996)

int left_hand_method(int, int, int *, int *);   // 함수 선언
int right_hand_method(int, int, int *, int *);

int miro[11][11] = { 0 };   // 배열을 활용해 미로 설정
int miro_left[11][11] = {
   {1,1,1,1,1,1,1,1,1,1,1},
   {1,0,0,0,0,0,0,0,0,0,1},
   {1,0,1,1,1,1,1,1,1,0,1},
   {1,0,1,0,0,0,0,0,1,0,1},
   {1,0,1,0,1,1,1,0,1,0,1},
   {1,0,1,0,0,0,1,0,1,0,1},
   {1,0,1,1,1,1,1,0,1,0,1},
   {1,0,0,0,0,0,0,0,1,0,1},
   {1,1,1,1,1,1,1,1,1,0,1},
   {1,0,0,0,0,0,0,0,0,0,1},
   {1,1,1,1,1,1,1,1,1,1,1}
};
int miro_right[11][11] = {
   {1,1,1,1,1,1,1,1,1,1,1},
   {1,0,0,0,0,0,0,0,0,0,1},
   {1,0,1,1,1,1,1,1,1,0,1},
   {1,0,1,0,0,0,0,0,1,0,1},
   {1,0,1,0,1,1,1,0,1,0,1},
   {1,0,1,0,1,0,0,0,1,0,1},
   {1,0,1,0,1,1,1,1,1,0,1},
   {1,0,1,0,0,0,0,0,0,0,1},
   {1,0,1,1,1,1,1,1,1,1,1},
   {1,0,0,0,0,0,0,0,0,0,1},
   {1,1,1,1,1,1,1,1,1,1,1}
};

int mode = 0, what = 0, map = 0;   // 변수 선언 및 초기값 설정
int x = 0, y = 0, x_result = 0, y_result = 0;



char way = 'r';   // 임의로 방향 설정
// u : 상 ; d : 하 ; l : 좌 ; r : 우

int main() {
    while (1) {

        printf("좌표 입력(좌표값을 띄어쓰기로 구분해 작성) : ");   // 좌표 입력
        scanf(" %d %d", &x, &y);

        //좌표값을 배열의 인덱스로 변환
        x = 11 - (2 * x);
        y = 2 * y + 1;
       
        printf("미로 선택(1 or 2) : ");//문제에 주어진 두 미로 중 하나를 선택
        scanf(" %d", &map);

        //선택한 미로를 miro로 복사하는 조건문과 반복문
        if (map == 1) {
            for (int i = 0; i < 11; i++) {
                for (int j = 0; j < 11; j++)
                    miro[i][j] = miro_left[i][j];   // for문을 활용해 선택한 미로 배열을 사용할 미로 배열에 대입
            }
        }
        else if (map == 2) {
            for (int i = 0; i < 11; i++) {
                for (int j = 0; j < 11; j++)
                    miro[i][j] = miro_right[i][j];   // for문을 활용해 선택한 미로 배열을 사용할 미로 배열에 대입
            }
        }
        else {//미로를 잘못 선택한 경우 예외처리구문
            printf("미로를 다시 입력해주세요.  \n");
            continue;
        }

        printf("좌수법 or 우수법 (1 or 2) : ");   // 좌수법, 우수법 선택
        scanf(" %d", &what);


        while (1) {//좌표찍기 위한 반복문
            if (what == 1) {
                mode = left_hand_method(x, y, &x_result, &y_result);   // 좌수법 함수 불러오기
            }
            else if (what == 2) {
                mode = right_hand_method(x, y, &x_result, &y_result);   // 우수법 함수 불러오기
            }

            if (mode == 0)
                break;

            //배열의 인덱스 값을 좌표값으로 변환 
            x_result = 6 - ((x_result + 1) / 2);
            y_result = (y_result + 1) / 2;

            printf(" -> (%d, %d)", x_result, y_result); // 출력
        }

        //좌표, 미로, 좌수법우수법, 관련 변수 초기화
        mode = what = map = x = y = x_result = y_result = 0;
    }
}


//매개변수로 좌표값을 변환한 배열의 인덱스값과 x_result, y_result의 주소를 받아 포인터를 이용해 이동한 좌표값을 구하였습니다.
int left_hand_method(int temp_x, int temp_y, int *x_r, int *y_r) { //좌수법 함수
    x = temp_x;
    y = temp_y;

    if ((x == 5) && (y == 5)){   // 현재 좌표가 설정한 도착 좌표와 같을 경우
        printf("\n도착했습니다.\n");
        return 0;//좌표찾기 종료
    }

    else {
        if (way == 'u'){   //진행방향이 위인 경우
            if (miro[x][y - 1] == 0){   // 현 진행방향에서 좌로 이동 가능시
                y--;   // 좌로 이동
                way = 'l';   // 진행방향 왼쪽으로 변경
            }
            else if (miro[x - 1][y] == 0){   // 현 진행방향에서 똑같을시
                x--;   // 진행방향 그대로 진행
                way = 'u';   //진행방향 위쪽으로 변경
            }
            else if (miro[x][y + 1] == 0){   // 현 진행방향에서 우로 이동 가능시
                y++;   // 우로 이동
                way = 'r';   // 진행방향을 오른쪽으로 변경
            }
            else if (miro[x + 1][y] == 0)   // 현 진행방향에서 하로 이동 가능시
            {
                x++;   // 아래로 이동
                way = 'd';   // 진행방향을 아래쪽으로 변경
            }
        }


        else if (way == 'd'){   //진행방향이 아래인 경우
            if (miro[x][y + 1] == 0){   // 현 진행방향에서 좌로 이동 가능시
                y++;   // 좌로 이동
                way = 'r';   // 진행방향을 오른쪽으로 변경
            }
            else if (miro[x + 1][y] == 0){   //  현 진행방향에서 똑같을시
                x++;   // 진행방향 그대로 진행
                way = 'd';   // 진행방향을 아래쪽으로 변경
            }
            else if (miro[x][y - 1] == 0){   // 현 진행방향에서 우로 이동 가능시
                y--;   // 우로 이동
                way = 'l';   // 진행방향을 왼쪽으로 변경
            }
            else if (miro[x - 1][y] == 0){   // 현 진행방향에서 위로 이동 가능시
                x--;   // 위로 이동
                way = 'u';   // 진행방향을 위쪽으로 변경
            }
            else{
                printf("\n아무 곳도 갈 수 없습니다.\n");
                return 0;
            }
        }
        else if (way == 'l'){   // 진행방향이 왼쪽인 경우
            if (miro[x + 1][y] == 0){   // 현 진행방향에서 좌로 이동 가능시
                x++;   // 좌로 이동
                way = 'd';   // 진행방향 아래쪽으로 변경
            }
            else if (miro[x][y - 1] == 0){   // 현 진행방향에서 똑같을시
                y--;   // 진행방향 그대로 진행
                way = 'l';   // 진행방향을 왼쪽으로 변경
            }
            else if (miro[x - 1][y] == 0){   // 현 진행방향에서 우로 이동 가능시
                x--;   // 우로 이동
                way = 'u';   // 진행방향을 위쪽으로 변경
            }
            else if (miro[x][y + 1] == 0){   // 현 진행방향에서 우로 이동 가능시
                y++;   // 진행방향 반대로 진행
                way = 'r';   // 진행방향을 오른쪽으로 변경
            }
        }
        else if (way == 'r'){   // 진행방향이 오른쪽인 경우
            if (miro[x - 1][y] == 0){   //  현 진행방향에서 좌로 이동 가능시
                x--;   // 좌로 이동
                way = 'u';   // 진행방향을 위쪽으로 변경
            }
            else if (miro[x][y + 1] == 0){   // 현 진행방향에서 똑같을시
                y++;   // 진행방향 그대로 진행
                way = 'r';   // 진행방향을 오른쪽으로 변경
            }
            else if (miro[x + 1][y] == 0){   // 현 진행방향에서 우로 이동 가능시
                x++;   // 우로 이동
                way = 'd';   // 진행방향을 아래쪽으로 변경
            }
            else if (miro[x][y - 1] == 0){   // 현 진행방향에서 좌로 이동 가능시
                y--;   // 좌로 이동
                way = 'l';   // 진행방향을 왼쪽으로 변경
            } 
        }
    }

    //포인터를 이용해 좌표값 대입
    *x_r = x;
    *y_r = y;
    return 1;
}


//좌수법 함수와 같은 방식입니다.
int right_hand_method(int temp_x, int temp_y, int* x_r, int* y_r){ //우수법 합수
    x = temp_x;
    y = temp_y;

    if ((x == 5) && (y == 5)){   // 현재 좌표가 설정한 도착 좌표와 같을 경우
        printf("\n도착했습니다.\n");//좌표찾기 종료
        return 0;
    }
    else{
        if (way == 'u'){//진행 방향이 상인 경우
            if (miro[x][y + 1] == 0){   //현 진행방향에서 우로 이동 가능시 우로 이동 후 진행방향 r로 변경
                y++;  
                way = 'r';   
            }
            else if (miro[x - 1][y] == 0){   //현 진행방향과 똑같을 시 그대로 이동 후 진행방향 u로 변경
                x--;    
                way = 'u';    
            }
            else if (miro[x][y - 1] == 0){   // 현 진행방향에서 좌로 이동 가능 시 좌로 이동 후 진행방향 l로 변경
                y--;    
                way = 'l';   
            }
            else if (miro[x + 1][y] == 0){   //현 진행방향에서 하로 이동 가능 시 하로 이동 후 진행방향 d로 변경
                x++;    
                way = 'd';  
            } 
        }
        else if (way == 'd'){//진행 방향이 하인 경우
            if (miro[x][y - 1] == 0){   //현 진행방향에서 우로 이동 가능 시 우로 이동 후 진행방향 ㅣ로 변경
                y--;    
                way = 'l'; 
            }
            else if (miro[x + 1][y] == 0){  //현 진행방향에서 똑같을 시 그대로 이동 후 진행방향 d로 변경
                x++;   
                way = 'd';   
            }
            else if (miro[x][y + 1] == 0){   // //현 진행방향에서 좌로 이동 가능 시 좌로 이동 후 진행방향 r로 변경
                y++;   
                way = 'r';  
            }
            else if (miro[x - 1][y] == 0){  //현 진행방향에서 상으로 이동 가능 시 상으로 이동 후 진행방향 u로 변경
                x--;    
                way = 'u';   
            }
        }
        else if (way == 'l'){//진행 방향이 좌인 경우
            if (miro[x - 1][y] == 0){ //현 진행방향에서 우로 이동 가능 시 우로 이동 후 진행방향 u로 변경
                x--;    
                way = 'u';    
            }
            else if (miro[x][y - 1] == 0){   //현 진행방향에서 똑같을 시 그대로 이동 후 진행방향 l로 변경
                y--;    
                way = 'l';  
            }
            else if (miro[x + 1][y] == 0){   //현 진행방향에서 좌로 이동 가능 시 좌로 이동 후 진행방향 d로 변경
                x++;    
                way = 'd';    
            }
            else if (miro[x][y + 1] == 0){   //현 진행방향에서 우로 이동 가능 시 우로 이동 후 진행방향 r로 변경
                y++;    
                way = 'r';  
            }
        }
        else if (way == 'r'){//진행 방향이 우인 경우
            if (miro[x + 1][y] == 0){   //현 진행방향에서 우로 이동 가능 시 우로 이동 후 진행방향 d로 변경
                x++;   
                way = 'd';   
            }
            else if (miro[x][y + 1] == 0){   //현 진행방향에서 똑같을 시 그대로 이동 후 진행방향 r로 변경
                y++;   
                way = 'r';    
            }
            else if (miro[x - 1][y] == 0){   //현 진행방향에서 좌로 이동 가능 시 좌로 이동 후 진행방향 u로 변경
                x--;    
                way = 'u';   
            }
            else if (miro[x][y - 1] == 0){  //현 진행방향에서 좌로 이동 가능 시 좌로 이동 후 진행방향 l로 변경
                y--;   
                way = 'l';    
            }
        }
    }
    //포인터를 이용해 좌표값 대입
    *x_r = x;
    *y_r = y;
    return 1;
}