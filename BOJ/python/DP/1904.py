# 1
T = [0] * 1000001
T[1] = 1
T[2] = 2

def num(n):
    if len(T)<=n:
        for i in range(len(T), n+1):
            T[i] = T[i-1] + T[i-2]
    print(T[n]%15746)
        
n = int(input())
num(n)

# 2
n = int(input())
cache = [0] * (n+2)
cache[1] = 1
cache[2] = 2

for i in range(3, n+1):
    cache[i] = (cache[i-1] + cache[i-2]) % 15746
print(cache[n])

# 3
n=int(input())
a=b=1
for i in range(n):
    a,b=b,(a+b)%15746

print(a)

""" 1904
N일 때 타일의 가짓수의 규칙을 찾아내는 것이 핵심이다. 동적 프로그래밍 특징: 한번 구한 값은 다시 구하지 않는다.
N의 타일의 가짓수는 (N-1)+(N-2)이다. 
(N-1)의 타일 조합에 1을 추가하면 N개의 타일 조합이고, (N-2)의 타일 조합에 00을 추가하면 N개의 타일 조합이 된다. 

# 1 틀린 풀이, 피보나치 수열과 비슷하게 코드를 짰다. 근데 틀렸다. 왜지
사실 한번만 수행하면 되므로 함수로 짤 필요가 없다. 또한 이전값과, 이전전값만 필요하므로 리스트를 사용하는것은 불필요하다.
#3의 코드가 #2의 코드보다 시간과 메모리의 값이 절반으로 줄어들었다.
"""
